import React from 'react';
import { findNodeHandle, Platform, StyleSheet } from 'react-native';
import WorkletEventHandler from './reanimated2/WorkletEventHandler';
import setAndForwardRef from './setAndForwardRef';
import './reanimated2/layoutReanimation/LayoutAnimationRepository';
import invariant from 'invariant';
import { adaptViewConfig } from './ConfigHelper';
import { RNRenderer } from './reanimated2/platform-specific/RNRenderer';
import { makeMutable, runOnUI, enableLayoutAnimations, } from './reanimated2/core';
import { DefaultEntering, DefaultExiting, DefaultLayout, } from './reanimated2/layoutReanimation/defaultAnimations/Default';
import { isJest, isChromeDebugger, shouldBeUseWeb, } from './reanimated2/PlatformChecker';
import { initialUpdaterRun } from './reanimated2/animation';
import { getShadowNodeWrapperFromRef } from './reanimated2/fabricUtils';
function dummyListener() {
    // empty listener we use to assign to listener properties for which animated
    // event is used.
}
function flattenArray(array) {
    if (!Array.isArray(array)) {
        return [array];
    }
    const resultArr = [];
    const _flattenArray = (arr) => {
        arr.forEach((item) => {
            if (Array.isArray(item)) {
                _flattenArray(item);
            }
            else {
                resultArr.push(item);
            }
        });
    };
    _flattenArray(array);
    return resultArr;
}
function onlyAnimatedStyles(styles) {
    return styles.filter((style) => style === null || style === void 0 ? void 0 : style.viewDescriptors);
}
function isSameAnimatedStyle(style1, style2) {
    // We cannot use equality check to compare useAnimatedStyle outputs directly.
    // Instead, we can compare its viewsRefs.
    return (style1 === null || style1 === void 0 ? void 0 : style1.viewsRef) === (style2 === null || style2 === void 0 ? void 0 : style2.viewsRef);
}
const isSameAnimatedProps = isSameAnimatedStyle;
const has = (key, x) => {
    if (typeof x === 'function' || typeof x === 'object') {
        if (x === null || x === undefined) {
            return false;
        }
        else {
            return key in x;
        }
    }
    return false;
};
export default function createAnimatedComponent(Component, options) {
    invariant(typeof Component !== 'function' ||
        (Component.prototype && Component.prototype.isReactComponent), '`createAnimatedComponent` does not support stateless functional components; ' +
        'use a class component instead.');
    class AnimatedComponent extends React.Component {
        constructor(props) {
            super(props);
            this._styles = null;
            this._viewTag = -1;
            this._isFirstRender = true;
            this.animatedStyle = { value: {} };
            this.initialStyle = {};
            this._component = null;
            this._setComponentRef = setAndForwardRef({
                getForwardedRef: () => this.props.forwardedRef,
                setLocalRef: (ref) => {
                    // TODO update config
                    const tag = findNodeHandle(ref);
                    if ((this.props.layout || this.props.entering || this.props.exiting) &&
                        tag != null) {
                        if (!shouldBeUseWeb()) {
                            enableLayoutAnimations(true, false);
                        }
                        let layout = this.props.layout ? this.props.layout : DefaultLayout;
                        let entering = this.props.entering
                            ? this.props.entering
                            : DefaultEntering;
                        let exiting = this.props.exiting
                            ? this.props.exiting
                            : DefaultExiting;
                        if (has('build', layout)) {
                            layout = layout.build();
                        }
                        if (has('build', entering)) {
                            entering = entering.build();
                        }
                        if (has('build', exiting)) {
                            exiting = exiting.build();
                        }
                        const config = {
                            layout,
                            entering,
                            exiting,
                            sv: this.sv,
                        };
                        runOnUI(() => {
                            'worklet';
                            global.LayoutAnimationRepository.registerConfig(tag, config);
                        })();
                    }
                    if (ref !== this._component) {
                        this._component = ref;
                    }
                },
            });
            if (isJest()) {
                this.animatedStyle = { value: {} };
            }
            this.sv = makeMutable({});
        }
        componentWillUnmount() {
            this._detachNativeEvents();
            this._detachStyles();
            this.sv = null;
        }
        componentDidMount() {
            this._attachNativeEvents();
            this._attachAnimatedStyles();
        }
        _attachNativeEvents() {
            const viewTag = findNodeHandle(this);
            for (const key in this.props) {
                const prop = this.props[key];
                if (has('current', prop) &&
                    prop.current instanceof WorkletEventHandler) {
                    prop.current.registerForEvents(viewTag, key);
                }
            }
        }
        _detachNativeEvents() {
            for (const key in this.props) {
                const prop = this.props[key];
                if (has('current', prop) &&
                    prop.current instanceof WorkletEventHandler) {
                    prop.current.unregisterFromEvents();
                }
            }
        }
        _detachStyles() {
            var _a;
            if (Platform.OS === 'web' && this._styles !== null) {
                for (const style of this._styles) {
                    if (style === null || style === void 0 ? void 0 : style.viewsRef) {
                        style.viewsRef.remove(this);
                    }
                }
            }
            else if (this._viewTag !== -1 && this._styles !== null) {
                for (const style of this._styles) {
                    style.viewDescriptors.remove(this._viewTag);
                }
                if ((_a = this.props.animatedProps) === null || _a === void 0 ? void 0 : _a.viewDescriptors) {
                    this.props.animatedProps.viewDescriptors.remove(this._viewTag);
                }
                if (global._IS_FABRIC) {
                    const shadowNodeWrapper = getShadowNodeWrapperFromRef(this);
                    runOnUI(() => {
                        'worklet';
                        _removeShadowNodeFromRegistry(shadowNodeWrapper);
                    })();
                }
            }
        }
        _reattachNativeEvents(prevProps) {
            let viewTag;
            for (const key in this.props) {
                const prop = this.props[key];
                if (has('current', prop) &&
                    prop.current instanceof WorkletEventHandler) {
                    if (viewTag === undefined) {
                        viewTag = prop.current.viewTag;
                    }
                }
            }
            for (const key in prevProps) {
                const prop = this.props[key];
                if (has('current', prop) &&
                    prop.current instanceof WorkletEventHandler &&
                    prop.current.reattachNeeded) {
                    prop.current.unregisterFromEvents();
                }
            }
            for (const key in this.props) {
                const prop = this.props[key];
                if (has('current', prop) &&
                    prop.current instanceof WorkletEventHandler &&
                    prop.current.reattachNeeded) {
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    prop.current.registerForEvents(viewTag, key);
                    prop.current.reattachNeeded = false;
                }
            }
        }
        _updateFromNative(props) {
            var _a, _b;
            if (options === null || options === void 0 ? void 0 : options.setNativeProps) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                options.setNativeProps(this._component, props);
            }
            else {
                // eslint-disable-next-line no-unused-expressions
                (_b = (_a = this._component) === null || _a === void 0 ? void 0 : _a.setNativeProps) === null || _b === void 0 ? void 0 : _b.call(_a, props);
            }
        }
        _attachAnimatedStyles() {
            var _a, _b, _c;
            const styles = this.props.style
                ? onlyAnimatedStyles(flattenArray(this.props.style))
                : [];
            const prevStyles = this._styles;
            this._styles = styles;
            const prevAnimatedProps = this._animatedProps;
            this._animatedProps = this.props.animatedProps;
            let viewTag;
            let viewName;
            let shadowNodeWrapper = null;
            if (Platform.OS === 'web') {
                viewTag = findNodeHandle(this);
                viewName = null;
                shadowNodeWrapper = null;
            }
            else {
                // hostInstance can be null for a component that doesn't render anything (render function returns null). Example: svg Stop: https://github.com/react-native-svg/react-native-svg/blob/develop/src/elements/Stop.tsx
                const hostInstance = RNRenderer.findHostInstance_DEPRECATED(this);
                if (!hostInstance) {
                    throw new Error('Cannot find host instance for this component. Maybe it renders nothing?');
                }
                // we can access view tag in the same way it's accessed here https://github.com/facebook/react/blob/e3f4eb7272d4ca0ee49f27577156b57eeb07cf73/packages/react-native-renderer/src/ReactFabric.js#L146
                viewTag = hostInstance === null || hostInstance === void 0 ? void 0 : hostInstance._nativeTag;
                /**
                 * RN uses viewConfig for components for storing different properties of the component(example: https://github.com/facebook/react-native/blob/master/Libraries/Components/ScrollView/ScrollViewViewConfig.js#L16).
                 * The name we're looking for is in the field named uiViewClassName.
                 */
                viewName = (_a = hostInstance === null || hostInstance === void 0 ? void 0 : hostInstance.viewConfig) === null || _a === void 0 ? void 0 : _a.uiViewClassName;
                // update UI props whitelist for this view
                const hasReanimated2Props = ((_b = this.props.animatedProps) === null || _b === void 0 ? void 0 : _b.viewDescriptors) || styles.length;
                if (hasReanimated2Props && (hostInstance === null || hostInstance === void 0 ? void 0 : hostInstance.viewConfig)) {
                    adaptViewConfig(hostInstance.viewConfig);
                }
                if (global._IS_FABRIC) {
                    shadowNodeWrapper = getShadowNodeWrapperFromRef(this);
                }
            }
            this._viewTag = viewTag;
            // remove old styles
            if (prevStyles) {
                // in most of the cases, views have only a single animated style and it remains unchanged
                const hasOneSameStyle = styles.length === 1 &&
                    prevStyles.length === 1 &&
                    isSameAnimatedStyle(styles[0], prevStyles[0]);
                if (!hasOneSameStyle) {
                    // otherwise, remove each style that is not present in new styles
                    for (const prevStyle of prevStyles) {
                        const isPresent = styles.some((style) => isSameAnimatedStyle(style, prevStyle));
                        if (!isPresent) {
                            prevStyle.viewDescriptors.remove(viewTag);
                        }
                    }
                }
            }
            styles.forEach((style) => {
                style.viewDescriptors.add({
                    tag: viewTag,
                    name: viewName,
                    shadowNodeWrapper,
                });
                if (isJest()) {
                    /**
                     * We need to connect Jest's TestObject instance whose contains just props object
                     * with the updateProps() function where we update the properties of the component.
                     * We can't update props object directly because TestObject contains a copy of props - look at render function:
                     * const props = this._filterNonAnimatedProps(this.props);
                     */
                    this.animatedStyle.value = Object.assign(Object.assign({}, this.animatedStyle.value), style.initial.value);
                    style.animatedStyle.current = this.animatedStyle;
                }
            });
            // detach old animatedProps
            if (prevAnimatedProps &&
                !isSameAnimatedProps(prevAnimatedProps, this.props.animatedProps)) {
                prevAnimatedProps.viewDescriptors.remove(viewTag);
            }
            // attach animatedProps property
            if ((_c = this.props.animatedProps) === null || _c === void 0 ? void 0 : _c.viewDescriptors) {
                this.props.animatedProps.viewDescriptors.add({
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    tag: viewTag,
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    name: viewName,
                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                    shadowNodeWrapper: shadowNodeWrapper,
                });
            }
        }
        componentDidUpdate(prevProps) {
            this._reattachNativeEvents(prevProps);
            this._attachAnimatedStyles();
        }
        _filterNonAnimatedProps(inputProps) {
            const props = {};
            for (const key in inputProps) {
                const value = inputProps[key];
                if (key === 'style') {
                    const styleProp = inputProps.style;
                    const styles = flattenArray(styleProp !== null && styleProp !== void 0 ? styleProp : []);
                    const processedStyle = styles.map((style) => {
                        if (style && style.viewDescriptors) {
                            // this is how we recognize styles returned by useAnimatedStyle
                            style.viewsRef.add(this);
                            if (this._isFirstRender) {
                                this.initialStyle = Object.assign(Object.assign({}, style.initial.value), initialUpdaterRun(style.initial.updater));
                            }
                            return this.initialStyle;
                        }
                        else {
                            return style;
                        }
                    });
                    props[key] = StyleSheet.flatten(processedStyle);
                }
                else if (key === 'animatedProps') {
                    const animatedProp = inputProps.animatedProps;
                    if (animatedProp.initial !== undefined) {
                        Object.keys(animatedProp.initial.value).forEach((key) => {
                            var _a, _b;
                            props[key] = (_a = animatedProp.initial) === null || _a === void 0 ? void 0 : _a.value[key];
                            (_b = animatedProp.viewsRef) === null || _b === void 0 ? void 0 : _b.add(this);
                        });
                    }
                }
                else if (has('current', value) &&
                    value.current instanceof WorkletEventHandler) {
                    if (value.current.eventNames.length > 0) {
                        value.current.eventNames.forEach((eventName) => {
                            props[eventName] = has('listeners', value.current)
                                ? value.current.listeners[eventName]
                                : dummyListener;
                        });
                    }
                    else {
                        props[key] = dummyListener;
                    }
                }
                else if (key !== 'onGestureHandlerStateChange' ||
                    !isChromeDebugger()) {
                    props[key] = value;
                }
            }
            return props;
        }
        render() {
            const props = this._filterNonAnimatedProps(this.props);
            if (isJest()) {
                props.animatedStyle = this.animatedStyle;
            }
            if (this._isFirstRender) {
                this._isFirstRender = false;
            }
            const platformProps = Platform.select({
                web: {},
                default: { collapsable: false },
            });
            return (<Component {...props} ref={this._setComponentRef} {...platformProps}/>);
        }
    }
    AnimatedComponent.displayName = `AnimatedComponent(${Component.displayName || Component.name || 'Component'})`;
    return React.forwardRef((props, ref) => {
        return (<AnimatedComponent {...props} {...(ref === null ? null : { forwardedRef: ref })}/>);
    });
}
